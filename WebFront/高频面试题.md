1、watch与computed的区别

2、vue.nextTick实现原理

3、如何做到的双向绑定

4、webpack的plugin与loader的区别

[Loader](https://webpack.docschina.org/concepts/loaders/)对不同文件格式的转换器，通常是对传入的代码进行分析，转为AST，遍历进行定向的修改，再重新生成代码字符串。

比如`babel-loader`的处理过程
* `baylon`将`ES6/ES7`的代码解析成`AST`
* `babel-traverse`对`AST`进行遍历转译，得到新的`AST`
* 新的`AST`通过`babel-generator`转换为`ES5`

[Plugin](https://webpack.docschina.org/concepts/plugins/)在webpack的编译的整个生命周期内，监听钩子事件，根据需求在相应的时间点对打包内容进行定向的修改。

Plugin需要提供apply方法，接收compiler对象，通过compiler提供的API对Webpack编译期间的事件进行监听，并执行相应的操作

上传静态资源到CDN的Webpack插件
* 监听hook：afterEmit，输出asset到output目录后执行
* 收集资源文件，使用阿里云OS的SDK上传到阿里云的CDN

5、webpack执行的过程

5.1 读取配置文件，初始化参数，创建Compiler对象
5.2 挂在插件，调用插件的apply方法
5.3 从entry入口开始进行编译
5.4 按文件类型调用相应的Loader对模快进行编译，并在合适的时机触发事件，调用Plugin执行。最后根据模快的依赖查找到所有的依赖模快，并递归处理
5.5 将编译后的代码打包为一个个chunk，并按照依赖和配置输出内容
5.6 根据Output把文件内推输出到指定文件夹

编译优化

1. `Uglifyjs`进行`Js`代码压缩
2. `Tree shaking`，移除Js代码中未被引用的代码（`dead code`），可以通过`sideEffects`告知`webpack`代码无副作用，可安全删除
3. `Code-Spliting`，将代码分隔为多份进行懒加载或异步加载，避免打包成一份后体积过大，影响首屏的渲染
4. Scope hosting，作用域提升（使用插件`ModuleConcatenationPlugin`），将分散模快划分同一个作用域，避免代码重复引入，减小打包提交和运行时内存消耗（减少作用域的创建）
5. 使用`includes/exclude`指定搜索范围或排除不必要的搜索范围
6. `babel-loader`，忽略`node_modules`，开启`cacheDirectory`（缓存编译结果）
7. 使用`HappyPack`，开启多进程并发编译
8. 使用`DLLPlugin`缓存第三方模快
9. 使用`Webpack-bundle-analyzer`分析打包文件，避免重复打包
10. 关闭`source-map`

6、Javascript的垃圾回收机制

7、URL从输入到页面渲染全流程

8、vue和react谈谈区别和选型考虑

9、Virtual Dom 的优势在哪里

- 虚拟 DOM 最大的优势在于抽象了原本的渲染过程，实现了跨平台的能力，而不仅仅局限于浏览器的 DOM，可以是安卓和 IOS 的原生组件，可以是近期很火热的小程序，也可以是各种 GUI。

- vdom 把渲染过程抽象化了，从而使得组件的抽象能力也得到提升，并且可以适配 DOM 以外的渲染目标。

- Virtual DOM 在牺牲(牺牲很关键)部分性能的前提下，增加了可维护性，这也是很多框架的通性。
实现了对 DOM 的集中化操作，在数据改变时先对虚拟 DOM 进行修改，再反映到真实的 DOM中，用最小的代价来更新DOM，提高效率(提升效率要想想是跟哪个阶段比提升了效率，别只记住了这一条)。

- 打开了函数式 UI 编程的大门。

- 可以渲染到 DOM 以外的端，使得框架跨平台，比如 ReactNative，React VR 等。

- 可以更好的实现 SSR，同构渲染等。这条其实是跟上面一条差不多的。

- 组件的高度抽象化。

> 虚拟 DOM 的缺点

首次渲染大量 DOM 时，由于多了一层虚拟 DOM 的计算，会比 innerHTML 插入慢。
虚拟 DOM 需要在内存中的维护一份 DOM 的副本(更上面一条其实也差不多，上面一条是从速度上，这条是空间上)。
如果虚拟 DOM 大量更改，这是合适的。但是单一的，频繁的更新的话，虚拟 DOM 将会花费更多的时间处理计算的工作。所以，如果你有一个DOM 节点相对较少页面，用虚拟 DOM，它实际上有可能会更慢。但对于大多数单页面应用，这应该都会更快。

10、网站性能优化

网络层面--让资源体积更小加载更快

* 构建策略（Webpack）
  * 减小打包时间
  * 减小打包体积
* 图像策略
  * 图像选型
    * jpeg
    * png
    * webp
    * base64
    * css Sprite
  * 图像压缩
* 分发策略（CDN）
  * 所有静态资源（js/css/img/font/audio/video）走CDN
  * CDN域名与主站域名不一致，避免请求携带cookie
> CDN的核心特征：缓存和回源
* 缓存策略
  * 考虑是否拒绝一切缓存策略：Cache-control: no-store
  * 考虑是否每次都向服务器询问缓存状态：Cache-control: no-cache
  * 考虑是否缓存可以被代理服务器存储：Cache-control: public/private
  * 考虑是否关注缓存过期时间：Expires:t/Cache-control: max-age=t/s-maxage=t
  * 考虑是否使用协商缓存策略：Last-Modified/if-Modified-Sinc、ETAG/if-None-Match

渲染层面--让代码解析更好执行更快

* CSS策略
  * 避免出现超过三层的嵌套规则
  * 避免为ID选择器添加多余的选择器
  * 避免使用标签选择器代替类选择器
  * ~~避免使用通配选择器，只对目标节点声明规则~~
  * 避免重复匹配重复定义，关注可继承属性
* DOM策略
  * 缓存DOM计算属性（提前读取element.style/clientWidth等）
  * 避免过多操作DOM
  * 使用DOMFagment缓存批量化DOM操作
* 阻塞策略
  * script-defer
  * script-async
  * link-preload
  * link-prefetch
  * link-dns-prefetch
* 回流重绘策略
  * 元素移动使用transform替代对元素的left\top的操作
  * ~~使用类合并样式，避免逐条修改元素的样式~~
  * 对元素修改，先将元素离线化处理
  * requestAnimationFrame替代setInterval
* 异步更新策略
  * 大数据计算，利用事件循环（setTimeout）分隔处理
  * 使用webworker
  * 在微任务中修改DOM（queueMicrotask）
---

网络传输性能优化
* 浏览器缓存
* 资源打包压缩（公共资源拆分、Tree-shaking、代码分隔、GZIP）
* 图片使用WebP
* CDN（独立域名，DNS-Prefetch）

页面渲染性能优化
* SSR
* preload，预加载
* async，异步处理js

[写给中高级前端关于性能优化的9大策略和6大指标](https://segmentfault.com/a/1190000040343057)

11、介绍自己负责开发的项目

* 设计思路
* 运行原理
* 开发遇到问题，如何解决的
  * 文本内容的样式提取
  * 性能优化
    * 节流
    * 懒加载
    * 分页
* 哪些需要继续优化的点

12、callback、promise、generator异步编程、async/await

* callback回调低地狱
* promise的优势和带来的问题
* generator异步编程，co自执行器
* async/await注意点
* async/await和promise的性能差异

13、如何设计一个通用的组件（基础组件/业务组件）

* 要易用：至少让使用者能够简单方便的引入到工程，并有详细的文档说明
* 要稳定：有单测，功能内聚，降低耦合
* 要灵活：关键参数可配置
* 要全面：重点关注异常情况处理
* 要谨慎：有一定的容错机制或防御编程

14、node.js的进程与线程

* child_process、cluster
* spawn、exec、execFile、fork
* 进程通信
* cluster的特点
* worker_thread

[node-js-中的进程与线程](http://www.inode.club/node/processAndThread.html)

15、平时如何学习

* 利用碎片化时间
* 学会搜索和浏览技术社区
* 做好自己知识体系的建设，有重点，有目标的去学习补充新的知识

16、对未来的规划

1. 当前是一名P7工程师，希望未来有机会可以做到P8

做好单点的技术突破准备，lowcode平台钻研下去，开源，推广

2. 现在自身负责业务或者部门内，在发展中遇到的问题，已经可以解决。未来希望可以从整个公司的某个场景出发，发现其中的痛点，解决并推广自己的方案

工作中，不设限，不拘泥于自己负责的业务，了解其他团队的业务，多交流，多沟通，发现痛点，找到解决办法，做到利己利他

3. 未来可以带更大的团队

做好自己带团队的能力

17、对前端的理解

18、作为一个Leader如何带团队

选育用留
动如一人

19、作为一个Leader如何做好技术建设

什么是技术建设：
* 团队技术栈领先
* 团队工作开发效率高效

技术建设的目的：
* 支撑业务活在当下并更好的活在未来

技术建设怎么做
* 发现业务痛点
* 做好技术预备
* 做好工具和平台的建设
* 关注更多的技术动态，从本身业务场景触发，既做到解决业务问题有做到促进团队技术进步

[如何推动前端团队的基础设施建设](https://juejin.cn/post/6844904093434019853)

20、作为一个Leader如果过好项目管理（如何避免线上问题、保证线上稳定性）

1. 以业务功能的重压成都为依据，做好工程拆分，做好分级，PX P0
2. 关键业务的开发，做好人员后背，避免人员流动性造成项目的不稳定；并做好文档建设，技术栈要统一
3. 项目开发的流程要规范化：开发前做好规划（指定技术负责人、设计技术实施方案、测试Case评审、上线方案制定、回滚方案制定）、开发过程中，做到随时自测，有条件就上单元测试、提测前做好CodeReview、上线后做好回归和开发总结、BugReview进行查漏补缺

21、Node.js 流中的背压

[Node.js 指南（流中的背压）](https://segmentfault.com/a/1190000017505881)

22、Node.js的集群部署

23、设计一个日志框架需要考虑哪些问题，Node.js的日志监控如何做？

[大搜车 NodeJS 日志规范化与分析监控](https://juejin.cn/post/6844903439500050440)

24、Egg.js的多进程架构模型，Cluster实现worker共享同一个端口的原理

[Egg 源码解析之 egg-cluster](https://zhuanlan.zhihu.com/p/29374045)
[Egg 源码分析之 egg-core](https://zhuanlan.zhihu.com/p/47178799)
[通过源码解析 Node.js 中 cluster 模块的主要功能实现](https://cnodejs.org/topic/56e84480833b7c8a0492e20c)

25、Node.js服务的QPS是多少

[对node工程进行压力测试与性能分析](https://juejin.cn/post/6844903665166188551)

27、Vue中`$emit、$on、$off`的实现原理

* 每一个`Vue`实例都已一个内置的`_events`对象，其`key`为事件类型，`value`为事件回调函数的数组
* 模板中的`v-on/@`在经过`vue-loader`或`compiler`处理后，转为`render`函数中相应节点或组件的`on`属性
* 组件初始化的时候，在`InitEvents`时将`_parentListeners`注册到`_events`中

28、SCSS和Less预编译的区别

29、Vuex的实现原理

30、如何进行高效的多人协作

31、如何保证项目的可维护性

32、如何提供项目的开发质量

33、如何降低项目的生产风险

34、LandingPage平台的价值

* 运营提效
* Hubspot替换
* 数据闭环
* 前端解放

35、Egg.js的请求上下文Context如何在controller和service之家传递？

36、Node.js开发过程的的OOM问题，怎么解决？

页面配置读取，JSON转化，OOM，超时
* stream的方式处理数据，[node-sequelize-stream](https://github.com/nkovalenko93/sequelize-stream)，[JSONStream](https://github.com/dominictarr/JSONStream)

36、Node.js中的进程通信方法？socket进程通信的原理？

37、HTTPS的加密通信过程？

关键词：对称加密、非对称加密、CA机构、数字证书