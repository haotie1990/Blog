1、watch与computed的区别

2、vue.nextTick实现原理

3、如何做到的双向绑定

4、webpack的plugin与loader的区别

5、webpack执行的过程

6、Javascript的垃圾回收机制

7、URL从输入到页面渲染全流程

8、vue和react谈谈区别和选型考虑

9、Virtual Dom 的优势在哪里

- 虚拟 DOM 最大的优势在于抽象了原本的渲染过程，实现了跨平台的能力，而不仅仅局限于浏览器的 DOM，可以是安卓和 IOS 的原生组件，可以是近期很火热的小程序，也可以是各种 GUI。

- vdom 把渲染过程抽象化了，从而使得组件的抽象能力也得到提升，并且可以适配 DOM 以外的渲染目标。

- Virtual DOM 在牺牲(牺牲很关键)部分性能的前提下，增加了可维护性，这也是很多框架的通性。
实现了对 DOM 的集中化操作，在数据改变时先对虚拟 DOM 进行修改，再反映到真实的 DOM中，用最小的代价来更新DOM，提高效率(提升效率要想想是跟哪个阶段比提升了效率，别只记住了这一条)。

- 打开了函数式 UI 编程的大门。

- 可以渲染到 DOM 以外的端，使得框架跨平台，比如 ReactNative，React VR 等。

- 可以更好的实现 SSR，同构渲染等。这条其实是跟上面一条差不多的。

- 组件的高度抽象化。

> 虚拟 DOM 的缺点

首次渲染大量 DOM 时，由于多了一层虚拟 DOM 的计算，会比 innerHTML 插入慢。
虚拟 DOM 需要在内存中的维护一份 DOM 的副本(更上面一条其实也差不多，上面一条是从速度上，这条是空间上)。
如果虚拟 DOM 大量更改，这是合适的。但是单一的，频繁的更新的话，虚拟 DOM 将会花费更多的时间处理计算的工作。所以，如果你有一个DOM 节点相对较少页面，用虚拟 DOM，它实际上有可能会更慢。但对于大多数单页面应用，这应该都会更快。

10、网站性能优化

网络层面--让资源体积更小加载更快

* 构建策略（Webpack）
  * 减小打包时间
  * 减小打包体积
* 图像策略
  * 图像选型
    * jpeg
    * png
    * webp
    * base64
    * css Sprite
  * 图像压缩
* 分发策略（CDN）
  * 所有静态资源（js/css/img/font/audio/video）走CDN
  * CDN域名与主站域名不一致，避免请求携带cookie
> CDN的核心特征：缓存和回源
* 缓存策略
  * 考虑是否拒绝一切缓存策略：Cache-control: no-store
  * 考虑是否每次都向服务器询问缓存状态：Cache-control: no-cache
  * 考虑是否缓存可以被代理服务器存储：Cache-control: public/private
  * 考虑是否关注缓存过期时间：Expires:t/Cache-control: max-age=t/s-maxage=t
  * 考虑是否使用协商缓存策略：Last-Modified/if-Modified-Sinc、ETAG/if-None-Match

渲染层面--让代码解析更好执行更快

* CSS策略
  * 避免出现超过三层的嵌套规则
  * 避免为ID选择器添加多余的选择器
  * 避免使用标签选择器代替类选择器
  * ~~避免使用通配选择器，只对目标节点声明规则~~
  * 避免重复匹配重复定义，关注可继承属性
* DOM策略
  * 缓存DOM计算属性（提前读取element.style/clientWidth等）
  * 避免过多操作DOM
  * 使用DOMFagment缓存批量化DOM操作
* 阻塞策略
  * script-defer
  * script-async
  * link-preload
  * link-prefetch
  * link-dns-prefetch
* 回流重绘策略
  * 元素移动使用transform替代对元素的left\top的操作
  * ~~使用类合并样式，避免逐条修改元素的样式~~
  * 对元素修改，先将元素离线化处理
  * requestAnimationFrame替代setInterval
* 异步更新策略
  * 大数据计算，利用事件循环（setTimeout）分隔处理
  * 使用webworker
  * 在微任务中修改DOM（queueMicrotask）
---

网络传输性能优化
* 浏览器缓存
* 资源打包压缩（公共资源拆分、Tree-shaking、代码分隔、GZIP）
* 图片使用WebP
* CDN（独立域名，DNS-Prefetch）

页面渲染性能优化
* SSR
* preload，预加载
* async，异步处理js

[写给中高级前端关于性能优化的9大策略和6大指标](https://segmentfault.com/a/1190000040343057)

11、介绍自己负责开发的项目

* 设计思路
* 运行原理
* 开发遇到问题，如何解决的
  * 文本内容的样式提取
  * 性能优化
    * 节流
    * 懒加载
    * 分页
* 哪些需要继续优化的点

12、callback、promise、generator异步编程、async/await

* callback回调低地狱
* promise的优势和带来的问题
* generator异步编程，co自执行器
* async/await注意点
* async/await和promise的性能差异

13、如何设计一个通用的组件（基础组件/业务组件）

* 要易用：至少让使用者能够简单方便的引入到工程，并有详细的文档说明
* 要稳定：有单测，功能内聚，降低耦合
* 要灵活：关键参数可配置
* 要全面：重点关注异常情况处理
* 要谨慎：有一定的容错机制或防御编程

14、node.js的进程与线程

* child_process、cluster
* spawn、exec、execFile、fork
* 进程通信
* cluster的特点
* worker_thread

[node-js-中的进程与线程](http://www.inode.club/node/processAndThread.html)

15、平时如何学习

* 利用碎片化时间
* 学会搜索和浏览技术社区
* 做好自己知识体系的建设，有重点，有目标的去学习补充新的知识

16、对未来的规划

1. 当前是一名P7工程师，希望未来有机会可以做到P8

做好单点的技术突破准备，lowcode平台钻研下去，开源，推广

2. 现在自身负责业务或者部门内，在发展中遇到的问题，已经可以解决。未来希望可以从整个公司的某个场景出发，发现其中的痛点，解决并推广自己的方案

工作中，不设限，不拘泥于自己负责的业务，了解其他团队的业务，多交流，多沟通，发现痛点，找到解决办法，做到利己利他

3. 未来可以带更大的团队

做好自己带团队的能力

17、对前端的理解

18、作为一个Leader如何带团队

选育用留
动如一人

19、作为一个Leader如何做好技术建设

什么是技术建设：
* 团队技术栈领先
* 团队工作开发效率高效

技术建设的目的：
* 支撑业务活在当下并更好的活在未来

技术建设怎么做
* 发现业务痛点
* 做好技术预备
* 做好工具和平台的建设
* 关注更多的技术动态，从本身业务场景触发，既做到解决业务问题有做到促进团队技术进步

[如何推动前端团队的基础设施建设](https://juejin.cn/post/6844904093434019853)

20、作为一个Leader如果过好项目管理（如何避免线上问题、保证线上稳定性）

1. 以业务功能的重压成都为依据，做好工程拆分，做好分级，PX P0
2. 关键业务的开发，做好人员后背，避免人员流动性造成项目的不稳定；并做好文档建设，技术栈要统一
3. 项目开发的流程要规范化：开发前做好规划（指定技术负责人、设计技术实施方案、测试Case评审、上线方案制定、回滚方案制定）、开发过程中，做到随时自测，有条件就上单元测试、提测前做好CodeReview、上线后做好回归和开发总结、BugReview进行查漏补缺
